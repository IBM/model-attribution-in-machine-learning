void append(int num)\n{\n    struct node *temp,*right;\n    temp= (struct node *)malloc(sizeof(struct node));\n    temp->data=num;\n    right=(struct node *)head;\n    while(right->next != NULL)\n    right=right->next;\
#include<stdio.h>\n#include<time.h>\n#include<windows.h>\n#include <stdlib.h>\n \nint main()\n{\nstruct tm *tmp;\ntime_t s;\n \nfor(;;)\n{\ns = time(NULL);\ntmp = localtime(&t);\n \n    printf("%d:%0d:%d\n",tmp->tm_hour,tmp
#include <iostream>\n#include <iomanip>\nusing namespace std;\nint** comb(int** a , int row , int col)\n{\n   int mid = col/2;\n         for( int i = 0 ; i < row ; i++)\n         for( int j = 0 ; j < col ; j++)\n                a[i][j] = 0;\n                a[0][mid] = 1;\
void disp(int** ptr, int row, int col)\n{\n  cout << endl << endl;\n    for ( int i = 0 ; i < row ; i++)\n        {\n        for ( int j = 0 ; j < col ; j++)\n            {\n                if( ptr[i][j] == 0)\n                cout << "   ";\n                else\n                cout << setw(4) << right << ptr[i][j];\n            }\
void remchars(char *str, char c);\nvoid remcnks(char *str, char *cnk);\nvoid replchars(char *str, char c1, char c2);\nvoid replcnks(char *str, char *cnk1, char *cnk2);\nvoid reverse(char *str);\n \n//remove specified characters from a string\nvoid remchars(char *str, char c)\n{\n    char *pos;\n    while(pos = strchr(str,c))\n        memmove(pos, pos + 1, strlen(pos));\n}\n \n//remove specified chunks from a string\nvoid remcnks(char *str, char *cnk)\n{\n    char *pos;\n    int clen = strlen(cnk);\n    while(pos = strstr(str, cnk))\n        memmove(pos, pos + clen, strlen(pos) - clen + 1);\n}\n \n//replace specified characters in a string\nvoid replchars(char *str, char c1, char c2)\n{\n    char *pos;\
//replace specified chunks in a string (size-independent, just remember about memory)\nvoid replcnks(char *str, char *cnk1, char *cnk2)\n{\n    char *pos;\n    int clen1 = strlen(cnk1), clen2 = strlen(cnk2);\n    while(pos = strstr(str, cnk1))\n    {\n        memmove(pos + clen2, pos + clen1, strlen(pos) - clen1 + 1);\n        memcpy(pos, cnk2, clen2);\n    }\n}\n \n//reverse a string\nvoid reverse(char *str)\n{\n    int i;\n    int len = strlen(str) - 1;\n    int mid = (len % 2) ? (len / 2) : ((len + 1) / 2);\n    for(i = 0; i <= mid; ++i)\n    {\
#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <math.h>\n \nlong int Sum_of_Dig(long int Number)\n{\n    static long int sum=0;\n    if (Number==0)\n    {  return(sum);\n \n    }\n    else\n    {\n    sum=sum+Number%10+Sum_of_Dig(Number/10);\n    }\n    return(sum);\n}\n \nint main()\n{\n    long int Num=0,Sum_dig=0;\n    printf("\n Enter Number : ");\n    scanf(\"%ld\",&Num);\n    Sum_dig=Sum_of_Dig(Num);\n    printf("\n Sum Of Digits :%ld  ",Sum_dig);\n    return(0);\n \n}";
#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n \n#define MAX 512 // max key length\n \nvoid xorenc(char *inname, char *outname, char *key);\n \nint main(int argc, char **argv)\n{\n    char input[MAX], *key;\n \n    if(argc != 3) // check the arguments\n    {\n        printf("ERROR: invalid arguments\n\n");\n        printf("Usage:\n");\n        printf("%s [input] [output]\n", argv[0]);\n        return EXIT_FAILURE;\n    }\n     \n    /* get the key */\n    printf("Key plz: ");\n    fgets(input, MAX, stdin);\n    key = malloc(strlen(input) + 1);\n    strcpy(key, input);\n     \n    xorenc(argv[1], argv[2], key);\n     \n    free(key);\n    return 0;\n}\n \nvoid xorenc(char *inname, char *outname, char *key)\n{\n    FILE *input, *output;\n    char c[1];\n    int i, k;\n     \n    input = fopen(inname, "rb");\n    output = fopen(outname, "wb");\n     \n    k = strlen(key);\n    i = 0;\n    while((fread(c, 1, 1, input)) != 0)\n    {\n        c[0] ^= key[i++]; // xor the input file's char with key's char\n        fwrite(c, 1, 1, output); // write the (en/de)crypted char to output\n        if(i == k) i = 0; // rewind the key if input is longer than it\n    }\n     \n    fclose(input);\
#include<sys/types.h>\n#include<dirent.h>\n#include<stdio.h>\n#include<string.h>\nint main(int argc,char *argv [])\n{\n     \n    DIR *dp;\n    char st[100];\n    struct dirent *ep;\n    if(argc<2)\n    {\n        printf("\nPlease specify the file path\n");\n        gets(st);\n        dp=opendir(st);\n \n    }\n    else\n    dp=opendir(argv[1]);\n    while((ep=readdir(dp)))\n    puts(ep->d_name);\n           closedir(dp);\n    return 0;\n \n}";
#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <ctype.h>\n \nint main()\n{\n    int x,div=2;\n \n \n    int i=0,j=0;\n    printf("Enter Number X : ");\n    scanf("%d",&x);\n    int num=x;\n    int *prime=(int *) malloc(x*sizeof(int));\n    printf("\n Allocated \n");\n    getch();\n    if (x==1 || x==0)\n    { printf(" Number %d have no prime Factors",x);\n    *prime=0;\n    }\n    else\n    { while(x>1)\n    {  if ((x%div)==0)\n        { *(prime+i)=div;x=x/div;i++;printf("\n Prime Factor\n");\n \n        }\n        else\n        { div++; }\n \n    }\n \n \n    }\n \n    printf("\n The Prime Factors for Number %d are  :\n",num);\n \n    for(j=0;j<i;j++)\n \n    { printf (" %d ",*(prime+j));   }\n \n    return(0);\n} \
struct node\n{\n   int i;\n   struct node *pNext;\n};\ntypedef struct node Node;\n\nNode* createList()\n{\n   Node *ph, *pc = 0;\n    \n   ph = (Node *) malloc(sizeof(Node));\n   ph->i = 0;\n   ph->pNext = 0;\n\n   pc = ph;\n   for (int i=1; i<=10; i++)\n   {\n       pc->pNext = (Node *) malloc(sizeof(Node));\n\n       pc = pc->pNext;\n       pc->i = i;\n       pc->pNext = 0;\n   }\n\n   return ph;\n}\n\nvoid printList(Node *ph)\n{\n   Node *pc=ph;\n\n   while(pc)\n   {\n       printf("%d\n", pc->i);\n       pc = pc->pNext;\n   }\n}\n\nvoid freeList(Node *ph)\n{\n   Node *pn, *pc=ph;\n\n   while(pc)\n   {\n       pn = pc->pNext;\n       free(pc);\n       pc=pn;\n   }\n}';
#include <stdio.h>\n \nchar **createMultiD(int subscriptOne, int subscriptTwo);\n \nint main(void)\n{\n    char **multi;\n     \n    multi = createMultiD(5, 5);\n     \n    /* multi can now be treated as a multidimensional array */\n     \n    multi[4][4] = 'X';\n     \n    printf("%c\n", multi[4][4]);\n}\n \n/* The actual function */\n \nchar **createMultiD(int subscriptOne, int subscriptTwo)\n{\n     char **multi;\n     int ctr = 0;\n      \n     /* Assigns an array of pointers to multi. */\n     /* This acts as the first array subscript. */\n     multi = (char **)malloc(sizeof(char *) * subscriptOne);\n      \n     if(multi == NULL)\n     {\n              /* Immediate termination of the function */\n              return(multi);         \n     }\n      \n     /* Assigns an array of characters to each pointer in multi. */\n     /* This acts as the second array subscript. */\n     for(ctr = 0; ctr <= subscriptTwo; ctr++)\n     {\n             multi[ctr] = (char *)malloc(sizeof(char) * subscriptTwo);\n     }\n      \n     return(multi);\n}\n\
void initarr(int ****array,int hyp_sz,int plane_sz,int row_sz,int col_sz);\n \nint main(void)\n{\n    int ****array;\n    int hyp_sz = d4,plane_sz = d3,row_sz = d2,col_sz = d1;\n    int h,i,j;\n \n    array = malloc(hyp_sz * sizeof(int***));\n    if (array == NULL)\n    {\n        fprintf(stderr,"Out Of Memory");\n        exit(EXIT_FAILURE);\n    }\n \n    for(h = 0;h < hyp_sz;h++)\n    {\n        array[h] = malloc(plane_sz * sizeof(int**));\n        if(array[h] == NULL)\n        {\n            fprintf(stderr,"Out Of Memory");\n            exit(EXIT_FAILURE);\n        }\n \n        for(i = 0;i < plane_sz;i++)\n        {\n            array[h][i] = malloc(row_sz * sizeof(int*));\n            if(array[h][i] == NULL)\n            {\n                fprintf(stderr,"Out Of Memory");\n                exit(EXIT_FAILURE);\n            }\n            for(j = 0;j < row_sz;j++)\n            {\n                array[h][i][j] = malloc(col_sz * sizeof(int));\n                if(array[h][i][j] == NULL)\n                {\n                    fprintf(stderr,"Out Of Memory");\n                    exit(EXIT_FAILURE);\n                }\n            }\n        }\n    }\n    printf("\n\n");\n \n    initarr(array,hyp_sz,plane_sz,row_sz,col_sz);   // initialise and display array\n \n    getchar();\n    return 0;\n}

#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <float.h>\n \n/* DEFS */\n \ntypedef float node_data; //stack list data type - set for integers\n \ntypedef struct _node Node; //short name for the node type\nstruct _node //node structure format\n{\n    node_data data;\n    Node *next;\n};\n \ntypedef struct sentinel Sentinel; //stack sentinel\nstruct sentinel //sentinel node format\n{\n    int count;\n    node_data sum;\n    node_data max;\n    node_data min;\n    Node *head;\n    Node *last;\n};\n\
int main(void)\n{   \n    //stack initialization\n    Sentinel *sentinel = NULL;\n    stack_init(&sentinel);\n     \n    menu(sentinel);\n \n    return 0;\n}\n \n/* STACK LIST FOOS */\n \nvoid stack_init(Sentinel **sentinel)\n{\n    //initialization of sentinel information\n    *sentinel = malloc(sizeof(Sentinel));\n    Sentinel *sntnl = *sentinel;\n    sntnl -> count = 0;\n    sntnl -> sum = 0;\n    sntnl -> max = -FLT_MAX; //minGW fails @ FLT_MIN\n    sntnl -> min = FLT_MAX;\n    sntnl -> head = NULL;\n    sntnl -> last = NULL;\n}\n \nvoid stack_push(Sentinel *sentinel, node_data d)\n{\n    Node *node_new = malloc(sizeof(Node));\n    if(!node_new) {puts("Out of memory"); exit(EXIT_FAILURE);}\n     \n    //sentinel info\n    if(!(sentinel -> last))\n        sentinel -> last = node_new;\n     \n    //standard push [O(1)]\n    node_new -> data = d;\n    node_new -> next = sentinel -> head;\n    sentinel -> head = node_new;\n     \n    //sentinel info\n    ++(sentinel -> count);\n    sentinel -> sum += d;\n    if(d > sentinel -> max)\n        sentinel -> max = d;\n    if(d < sentinel -> min)\n        sentinel -> min = d;\n} \
void stack_append(Sentinel *sentinel, node_data d)\n{\n    Node *node_new = malloc(sizeof(Node));\n    if(!node_new) {puts("Out of memory"); exit(EXIT_FAILURE);}\n     \n    //node init\n    node_new -> data = d;\n    node_new -> next = NULL;\n     \n    if(!(sentinel -> head)) //if the stack is empty, just do the push [O(1)]\n    {   \n        //standard push\n        node_new -> next = sentinel -> head;\n        sentinel -> head = node_new;\n    }\n    else //otherwise append to the last node [O(n)]\n    {\n        Node *node_curr = sentinel -> head;\n         \n        while(node_curr)\n        {\n            if(!(node_curr -> next))\n            {\n                node_curr -> next = node_new;\n                break;\n            }\n            node_curr = node_curr -> next;\n        }\n    }");
void stack_drop(Sentinel *sentinel)\n{\n    Node *node_togo = sentinel -> last;\n    int flag = 0;\n     \n    if(node_togo)\n    {\n        //sentinel info [O(1)]\n        --(sentinel -> count);\n        sentinel -> sum -= node_togo -> data;\n        if(node_togo -> data == sentinel -> max)\n            flag = 1;\n        if(node_togo -> data == sentinel -> min)\n            flag += 2;\n         \n        //if there is only one node, inform the sentinel [O(1)]\n        if(sentinel -> head == sentinel -> last)\n        {\n            sentinel -> head = NULL;\n            sentinel -> last = NULL;\n        }\n         \n        //drop the last node [O(n)]\n        free(node_togo);\n        Node *node_curr = sentinel -> head;\n        while(node_curr)\n        {\n            if(node_curr -> next == node_togo)\n            {\n                sentinel -> last = node_curr;\n                node_curr -> next = NULL;\n                break;\n            }\n            node_curr = node_curr -> next;\n        }\n         \n        //sentinel info [O(n)]\n        switch(flag)\n        {\n        case 1:\n            sentinel -> max = stack_max(sentinel);\n            break;\n        case 2:\n            sentinel -> min = stack_min(sentinel);\n            break;\n        case 3:\n            sentinel -> max = stack_max(sentinel);\n            sentinel -> min = stack_min(sentinel);\n            break;\n        }\n    }\n}";
void stack_print(Sentinel *sentinel)\n{\n    Node *node_curr = sentinel -> head;\n \n    if(!sentinel -> head) //if the stack is empty, report it [O(1)]\n        puts("nothing");\n    else //otherwise print all the data from nodes [O(n)]\n    {\n        while(node_curr)\n        {\n            printf("%.4f ", node_curr -> data);\n            node_curr = node_curr -> next;\n        }\n        putchar('\n');\n    }\n}\n \nvoid stack_clear(Sentinel *sentinel)\n{\n    //pop everything [O(n)]\n    while(sentinel -> head)\n        stack_pop(sentinel);\n}\n\
int stack_elem(Sentinel *sentinel, node_data d)\n{\n    Node *node_curr = sentinel -> head;\n     \n    //traverse the stack in search for d [O(n)]\n    while(node_curr)\n    {\n        if(node_curr -> data == d)\n            return 1;\n        else\n            node_curr = node_curr -> next;\n    }\n    return 0;\n}\n \nint stack_count(Sentinel *sentinel, node_data d)\n{\n    Node *node_curr = sentinel -> head;\n    int n = 0;\n     \n    //traverse the stack in search for ds [O(n)]\n    while(node_curr)\n    {\n        if(node_curr -> data == d)\n            ++n;\n        node_curr = node_curr -> next;\n    }\n    return n;\n}';
void menu(Sentinel *sentinel)\n{\n    //variables\n    char command[64];\n    node_data x;\n    char info[] =\n        "\nAvailable commands are: \nprint, push x, pop,"\n        " len, sum, avg, max, \nmin, elem x, count x, "\n        "append x, drop, \nhead, last, clear, help, "\n        "exit.";\n     \n    puts("Welcome to the linked list command center");\n    puts(info);\n    printf("\n");\n     \n    //program menu\n    while(fgets(command, 64, stdin))\n    {\n        //PUSH\n        if(strstr(command, "push "))\n        {\n            sscanf(command, "push %f", &x);\n            stack_push(sentinel, x);\n            printf("Pushed %.4f\n", x);\n        }\n        //POP\n        else if(!strcmp(command, "pop\n"))\n        {\n            if(sentinel -> head)\n            {\n                stack_pop(sentinel);\n                puts("Popped the top node");\n            }\n            else\n                puts("Nothing to pop");\n        }\n        //LEN\n        else if(!strcmp(command, "len\n"))\n            printf("Stack length is %d\n", sentinel -> count);\
#include<stdio.h>\n#include<stdlib.h>\n\nint arr[100],i,j,position,n,element,choice;\n\nvoid menu();\n\nvoid insertion(){\n    printf("ENTER THE POSITION YOU WANT TO ENTER THE ELEMENT");\n    scanf("%d",&position);\n    position=position-1;\n    if(position>n-1){\n        printf("\n INVALID POSITION\n");\n        menu();\n    }\n    printf("ENTER THE ELEMENT ");\n    scanf("%d",&element);\n    for(i=n;i>=position;i--){\n        arr[i+1]=arr[i];\n    }\n    arr[position]=element;\n    n=n+1;\n    menu();\n}\n\nvoid traversing(){\n    printf("\n THE ARRAY ENTERED IS:--\n");\n    for(i=0;i<n;i++){\n       printf("%d\t",*(arr+i));\n    }\n    menu();\n}\n\nvoid deletion(){\n    printf("ENTER THE POSITION OF THE ELEMENT TO BE DELETED");\n    scanf("%d",&position);\n    position=position-1;\n        if(position>n-1){\n        printf("\n INVALID POSITION\n");\n        menu();\n    }\n    for(i=position;i<n;i++){\n        arr[i]=arr[i+1];\n    }\n    printf("ELEMENT IS DELETED!!!\n");\n    n=n-1;\n    menu();\n}";
#include<stdio.h>\nint main()\n{\n	int a[100],i,n,*add;\n	\n	printf("enter the size: ");\n	scanf("%d",&n);\n	\n	printf("enter the numbers: \n");\n	for(i=0;i<n;i++)\n	{\n		scanf("%d",&a[i]);\n	}\n	\n	for(i=0;i<n;i++)\n	{\n		add=a+i;\n		//add = &a[i]; would also return the same thing.\n		printf("The address of element %d is %u.\n",*add, add);\
#include <stdio.h>\nint main(){\n	/* variable declaration */\n	int numerator1, numerator2, denominator1, denominator2, \nnum_result, denom_result ;\n	/* Read each fraction */\n	printf("Please provide the first numerator:\n");\n	scanf("%d",&numerator1);\n	printf("Please provide the first denominator:\n");\n	scanf("%d",&denominator1);\n 	printf("Please provide the second numerator:\n");\n        scanf("%d",&numerator2);\n	printf("Please provide the second denominator:\n");\n	scanf("%d",&denominator2);\n	/*compare the demonators*/\n	if ( denominator1 == denominator2 ) {\n		num_result = numerator1 + numerator2;\n		denom_result = denominator1; /*  or 2, they are equal */\n	} else {\n		num_result = (numerator1 * denominator2) + (numerator2 * denominator1 );\n		denom_result = denominator1 * denominator2;\n	}\n	printf("The result of %d / %d  + %d / %d  is: %d / %d \n", numerator1,denominator1, numerator2, denominator2,num_result,denom_result);\n	return 0;\n}";
#include <stdio.h>\n#include <stdlib.h>\n\n// Function that performs the conversion\ndouble convertTemp(double initValue, int initScale, int finalScale){\n    double finalValue;\n    switch(initScale){\n        // Celsius\n        case 1:\n            // Celsius to Kelvin\n            if(finalScale == 1){\n                finalValue = initValue + 273.15;\n            }\n            // Celsius to Fahrenheit\n            else if(finalScale == 2){\n                finalValue = (initValue * 9 / 5) + 32;\n            }\n            break;\n        case 2:\n            // Kelvin to Celsius\n            if(finalScale == 1){\n                finalValue = initValue - 273.15;\n            }\n            // Kelvin to Fahrenheit\n            else if(finalScale == 2){\n                finalValue = ((initValue - 273.15) * 9 / 5) + 32;\n            }\n            break;\
#include <stdio.h>  \n#include <string.h> \n#include <stdlib.h>  \n\nint checkAnagram(char *str1, char *str2);\n\nint main()\n{\n    char str1[100], str2[100];\n    \n    printf("Function : whether two given strings are anagram :");\n    printf("\nExample : pears and  spare, stone and tones :");\n    \n    printf(" Input the  first String : ");\n    fgets(str1, sizeof str1, stdin);\n    printf(" Input the  second String : ");\n    fgets(str2, sizeof str2, stdin);\n \n    if(checkAnagram(str1, str2) == 1)\n    {\n       str1[strlen(str1)-1] = '\0';\n       str2[strlen(str2)-1] = '\0';\n       printf(" %s and %s are Anagram.\n\n",str1,str2);\n    } \n    else \n    {\n       str1[strlen(str1)-1] = '\0';\n       str2[strlen(str2)-1] = '\0';\n       printf(" %s and %s are not Anagram.\n\n",str1,str2);\n    }\n    return 0;\n}";
#include<stdio.h>\nvoid main()\n{ float a,r;\nprintf("Enter the Radius : ");\nscanf("%f",&s);\na=s*s;\nprintf("Area is %f",a);\n}f
#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h>\n\n#define RECT_ARRAY_SIZE 5\n\n/*\n * Rectangle structure has length and breadth.\n */\nstruct rect {\n	int length;\n	int breadth;\n};\n\n/*\n * Array of rectangle structs to be sorted.\n */\nstruct rect r[RECT_ARRAY_SIZE];\n/*\n * mutex lock to serialize the array of rectangle structs\n */\npthread_mutex_t lock;\n\n/*\n * The comparator to compare the 2 rectangle structures.\n * Comparison is based on area. \n */\nint area_comp(const void *r1, const void *r2) \n{\n	int area1, area2;\n\n	struct rect r1_t = *(const struct rect *)r1;\n	struct rect r2_t = *(const struct rect *)r2;\n\n	area1 = r1_t.length * r1_t.breadth;\n	area2 = r2_t.length * r2_t.breadth;\n\n	return area1 > area2 ? 1 : 0;\n}");
#include<stdio.h>\n\nint main() {\n   int number1, number2, addition, subtraction, multiplication, division, modulo;\n   printf("Enter two numbers :\n");\n   scanf("%d%d", & number1, & number2);\n   addition = number1 + number2;\n   subtraction = number1 - number2;\n   multiplication = number1 * number2;\n   division = number1 / number2;\n   modulo = number1 % number2;\n   printf("Addition of number 1 and number 2 : %d\n", addition);\n   printf("Subtraction of number 1 and number 2 : %d\n", subtraction);\n   printf("Multiplication of number 1 and number 2 : %d\n", multiplication);\n   printf("Division of number 1 and number 2 : %d\n", division);\n   printf("Modulo of number 1 and number 2 : %d\n", modulo);\n   return 0;\n\n}'
#include<stdlib.h>\n#include<stdio.h>\n#include<time.h>\n#include <stdbool.h>\n#include <math.h>\n#define MAX 10\n#define A "P"\n#define B "Q"\nint getRandom(int low, int high);\nint getValidInteger(int low, int high);\nunsigned int playerRoll(int low, int high);\n\nvoid seed(void)\n{\n	srand(time(NULL));\n}\nvoid space(unsigned int size) // create space\n{\n	printf("     ");\n}\nchar getDisplayType(unsigned int index, unsigned int playerPosition, char playerName) // check the index and return character\n{\n\n	if (playerName != '#')\n	{\n		if (index == playerPosition)\n			return playerName;\n\n		if (index == 0)\n			return ('C');\n\n		if (index % 3 == 0)\n			if (index % 5 == 0)\n				if (index % 7 == 0)\n					return('G');\n				else return ('L');\n			else return ('W');\n\n		if (index % 5 == 0)\n			if (index % 7 == 0)\n				return('G');\n			else return ('L');\n\n		if (index % 7 == 0) {\n			return('G');\n		}\n		else return (' ');\n	}\
#include<iostream>\n#include<math.h>\nusing namespace std;\nint main()\n{\n	long long int a;\n	cout<<"enter the no in binary\n";\n	cin>>a;\n	int b=0,j=0;\n	int c;\n	while(a!=0)\n	{\n		c=a%10;\n		b=b+c*pow(2,j);\n		j++;\n		a=a/10;\n	}\n	cout<<b;\n}";
struct Node {\n  int data;\n  Node* left;\n  Node* right;\n};\n\n/* Inorder Traversal of Binary tree */\n\nvoid inorderTraversal(Node* root) {\n    if (root == NULL)\n        return;\n    /* recurring on left child */\n    inorderTraversal(root->left);\n    \n    /* printing the data of node */\n    cout << root->data << " ";\n    \n    /* recurring on right child */\n    inorderTraversal(root->right);\n}\n\n/* Preorder Traversal of Binary tree */\n\nvoid preorderTraversal(Node* root) {\n    if (root == NULL)\n        return;\n    /* printing the data of node */\n    cout << root->data << " ";\n    \n    /* recurring on left child */\n    preorderTraversal(root->left);\n  \n    /* recurring on right child */\n    preorderTraversal(root->right);\n}\n\
/* Postorder Traversal of Binary tree */\n\nvoid postorderTraversal(Node* root) {\n    if (root == NULL)\n        return;\n    /* recurring on left child */\n    postorderTraversal(root->left);\n  \n    /* recurring on right child */\n    postorderTraversal(root->right);\n    \n    /* printing the data of node */\n    cout << root->data << " ";\n}";
int binarySearch(int array[], int number, int start, int end) {\n    /* if start index is get end index, check if that element is equals wanter nmber */\n	if(start >= end) {\n		return array[start] == number ? 0 : 1;\n	}\n\n	int tmp = (int) end / 2;\n    /* divide array length in half */\n    /* if number is greater than element in half, do search by start to tmp\n	 * else search by tmp to end\n     */\n	if(number == array[tmp]) {\n		return 0;\n	} else if(number > array[tmp]) {\n		return binarySearch(array, number, start, tmp);\n	} else {\n		return binarySearch(array, number, tmp, end);\n	}\n}";
#include <stdio.h>\nint main()\n{\n    int a=14, b= 7, c;\n    c =a&b;\n    printf("Value of c = %d\n",c);\n    return 0;\n\n}");
int main()\n{\n  int array[100], n, c, d, swap;\n \n  printf("Enter number of elements\n");\n  scanf("%d", &n);\n \n  printf("Enter %d integers\n", n);\n \n  for (c = 0; c < n; c++)\n    scanf("%d", &array[c]);\n \n  for (c = 0 ; c < n - 1; c++)\n  {\n    for (d = 0 ; d < n - c - 1; d++)\n    {\n      if (array[d] > array[d+1]) /* For decreasing order use < */\n      {\n        swap       = array[d];\n        array[d]   = array[d+1];\n        array[d+1] = swap;\n      }\n    }\n  }\n \n  printf("Sorted list in ascending order:\n");\n \n  for (c = 0; c < n; c++)\n     printf("%d\n", array[c]);\n \n  return 0;\n}");
#include <stdio.h>\n  int main() {\n    int a, b, c;\n    char ch;\n    printf("enter two number\n");\n    scanf("%d%d", & a, & b);\n    fflush(stdin);\n    //flush the input buffer. You might use this function if you think that there might be\n    //some data in input buffer which can create problems for you while taking user inputs from stdin.\n    printf("enter your choice\n");\n    printf("1. enter 1 for addition\n");\n    printf("2. enter 2 for subtraction\n");\n    printf("3. enter 3 for multiplication\n");\n    printf("4. Enter 4 for division\n");\n    printf("5. enter 5 for modulo division\n");\n    scanf("%c", & ch);\n    switch (ch) {\n    case '1':\n      c = a + b;\n      break;\n    case '2':\n      c = a - b;\n      break;\n    case '3':\n      c = a * b;\n      break;\n    case '4':\n      c = a / b;\n      break;\n    case '5':\n      c = a % b; //Modulus division only works with integers.\n      break;\n    default:\n      printf("wrong choice");\n    }\n    printf("calculated value=%d", c);\n\n    return 0;\n  }";
#include<stdio.h>\nmain()\n{\n    int principleAmount;\n    int numberOfYears;\n    int rateOfInterest;\n    int SimpleInterest;\n    printf("enter principleAmount\n",principleAmount);\n    scanf("%d",&principleAmount);\n    printf("enter number of year\n",numberOfYears);\n    scanf("%d",&numberOfYears);\n    printf("enter rate of interest\n",rateOfInterest);\n    scanf("%d",&rateOfInterest);\n\n    SimpleInterest=(principleAmount*numberOfYears*rateOfInterest)/100;\n    printf("Simple interest is %d",SimpleInterest);\n\n\n}\nFooter\n"
#include <stdio.h>\n\nint main()\n{\n	double c, k;\n	printf("Enter the desired temperature in Celcius:\n");\n	scanf("%c", &c);\n	k = c + 273.15;\n	printf("Converted value: %f K\n", k);\
#include <stdio.h>\n  int main() {\n    char ch;\n    printf("Enter a character\n");\n    scanf("%c", & ch);\n    if ((ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122))\n      printf("Entered character is an alphabet");\n    else if (ch >= 48 && ch <= 57)\n      printf("Entered character is a digit");\n    else\n      printf("Entered character is a special symbol");\n    return 0;\n\n  }",
printf("enter the no. you want to convert\n");\n	scanf("%lld",&n);\n	\n	printf("enter the base of no.\n");\n	scanf("%lld",&x);\n	\n	printf("enter the base to which you want to convert\n");\n	scanf("%lld",&y);\n	\n	while(n>0)\n	{\n		b=n%10;\n	    n=n/10;	\n        j++;	\n       	d=b*pow(x,j);\n	    a=d+a;//converted the no. to base 10\n	}\n	
scanf("%d", &n);\n    int arr[n][n];\n    for (i=0;i<n;i++)\n    {\n        for (j=0;j<n;j++)\n        {\n            scanf("%d ", &arr[i][j]);\n            //Taking diagonal sum of the matrix arr from the both side\n            if(arr[i][j]>=-100 && arr[i][j]<=100)\n            {\n                if(i==j)\n                {\n                    sum1+=arr[i][j];\n                }\n                if(j==(n-1-i))\n                {\n                    sum2+=arr[i][j];\n                }\n            }\n        }\n    }\n    // THe
int hex_decimal(char hex[]);\nint main()\n{\n    char hex[20];\n    int n,c;\n    printf("**----Program to Convert Decimal and Hexadeciaml Vice Versa----***\n\n");\n    printf("Choose Your Choice: \n");\n    printf("1.Decimal to Hexadecimal:\n");\n    printf("2.Hexadecimal to Decimal:\n\n");\n    scanf("%d",&c);\n    if (c==1)\n    {\n        printf("Enter decimal number: ");\n        scanf("%d",&n);\n        decimal_hex(n,hex);\n        printf("Hexadecimal number: %s",hex);\n    }\n    if (c==2)\n    {\n        printf("Enter hexadecimal number: ");\n        scanf("%s",hex);\n        printf("Decimal number: %d",hex_decimal(hex));\n    }\n    return 0;\n}\
int i=0,rem;\n   while (n!=0)\n   {\n       rem=n%16;\n       switch(rem)\n       {\n           case 10:\n             hex[i]='A';\n             break;\n           case 11:\n             hex[i]='B';\n             break;\n           case 12:\n             hex[i]='C';\n             break;\n           case 13:\n             hex[i]='D';\n             break;\n           case 14:\n             hex[i]='E';\n             break;\n           case 15:\n             hex[i]='F';\n             break;\n           default:\n             hex[i]=rem+'0';\n             break;\n       }\n       ++i;\n       n/=16;\n   }\n   hex[i]='\0';\
int hex_decimal(char hex[])  \n{\n    int i, length, sum=0;\n    for(length=0; hex[length]!='\0'; ++length);\n    for(i=0; hex[i]!='\0'; ++i, --length)\n    {\n        if(hex[i]>='0' && hex[i]<='9')\n            sum+=(hex[i]-'0')*pow(16,length-1);\n        if(hex[i]>='A' && hex[i]<='F')\n            sum+=(hex[i]-55)*pow(16,length-1);  \n        if(hex[i]>='a' && hex[i]<='f')\n            sum+=(hex[i]-87)*pow(16,length-1);\n    }\n    return sum;\n}";
int main() {\n   unsigned int number, temp, droot = 0;\n   printf("Enter a positive number: ");\n   scanf("%u", &number);\n   temp = number;\n   while(temp != 0) {\n      int digit = temp % 10;\n      droot += digit;\n      temp /=10;\n      if(temp == 0 && droot > 9) {\n         temp = droot;\n         droot = 0;\n      }\n   }\n   printf("The digital root of %u is %u\n", number, droot);\n   return 0;\n}","
#include<stdio.h>\nint main()\n{\n    int a,b;  /*declaration of variables*/\n    printf("Enter Two Numbers\n");\n    scanf("%d %d",&a,&b); /*Taking input of Two Variables*/\n    a=a+b; /*swapping */\n    b=a-b; /* the two */\n    a=a-b; /*numbers*/\n    printf("the number after swapping are %d %d\n",a,b);/*printing*/\n    return 0;\n}\\
printf("enter the values of a,b,c");\nscanf("%d",&a);\nscanf("%d",&b);\nscanf("%d",&c);\nsum = a+b+c;\nprintf("%d\n",sum);\n{\naverage = (a+b+c)%3;\nprintf("%d\n",average);\n}}");
#include <stdio.h>\n\nint main(){\n\nint number;\nprintf("Enter an integer number\n");\nscanf("%d",&number);\nif (number %2 ==0)\n   printf("The number %d is even\n",number);\nelse{\n   printf("The number %d is odd\n",number);\n}\nreturn 0;\n}";
#include<stdio.h>\nvoid main()\n{ int a,b;\nprintf("Enter two Numbers : ");\nscanf("%d %d",&a,&b);\nc=a*b;\nprintf("The Multiplication is %d",c);\n}";
scanf("%d", &n);\n\ns = n;\n\nfor (row = 1; row <= n; row++)  // Loop to print rows\n{\n  for (c = 1; c < s; c++)  // Loop to print spaces in a row\n    printf(" ");\n\n  s--;\n\n  for (c = 1; c <= 2*row - 1; c++) // Loop to print stars in a row\n    printf("*");\n\n  printf("\n");\n}\n");
